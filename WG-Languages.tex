\subsection{Languages and Abstractions}\label{sec:wg_lang}

Based on the definitions and survey from the corresponding tutorial
(see Section~\ref{sec:tut_lang}), this working group identified and
described three challenges faced by stream processing languages.

\emph{Variety of data models} is a challenge for stream processing
languages. A data model organizes elements of data with respect to
their semantics, their logical composition into data structures, and
their physical representation. Producers and consumers of streams to
and from a streaming application dictate data models it must handle,
and the application's own conversion and processing needs drive
additional data-model variety.  There is no consensus on what a stream
data item is. At one extreme, in StreamIt, each data item is a simple
number~\cite{thies_et_al_2002}, while at the other extreme, C-SPARQL
streams entire self-describing graphs~\cite{barbieri_et_al_2009}.
Streaming languages have so far failed to consolidate on a data model
because data-model variety is a difficult challenge.

Data-model variety causes streaming-specific issues, since the data
model affects the speed of serialization, transmission, compression,
and dynamic checks for the presence or absence of certain fields, and
because the online setting leaves no time for separate batch data
integration. Some stream processing languages are designed around
their data model, e.g., CQL on tuples~\cite{arasu_babu_widom_2006} or
path expressions on XML trees~\cite{diao_et_al_2002}. Furthermore, the
data model enables streaming-language compilers to provide helpful
error messages and optimizations.

The goal is for streaming languages to let the programmer use the
logical data model they find most convenient while letting the
compiler choose the best physical representation. Metrics of success
are the expressive power of the language along with its throughput,
latency, and resource consumption.

\emph{Veracity with simplicity} is a challenge for stream processing
languages. Veracity means producing accurate and factual results, and
simplicity means avoiding unnecessary language complexity. There are
several reasons why streaming veracity is hard. Sensors producing
input data have limitations on precision, energy, and memory. In
long-running and loosely-coupled streaming applications, stream
sources come and go. And approximate stream
algorithms~\cite{babcock_et_al_2002} and stream
mining~\cite{gaber_zaslavsky_krishnaswamy_2005} introduce additional
uncertainty. This is compounded by the lack of ground truth in an
online setting, and by the difficulty of anticipating and testing
every eventuality.

\begin{alltt}TODO\scriptsize 1 page
- Challenge: Veracity with simplicity (~0.25 pages)
  - what's unique to streaming
    - real-time response without having seen all the data
    - due to online setting, no time for separate batch data cleansing
    - in distributed setting, no global clock~\cite{lamport_1978}
  - what's unique to languages
    - studies in pervasive handling of uncertainty in
      stream-relational algebra \cite{ali_et_al_2009} \cite{tran_et_al_2010}
    - can limit operators to support revision and retraction
    - probabilistic programming languages can track uncertainty~\cite{gordon_et_al_2014}
  - goal(s)
    - minimize compounding uncertainty
    - quality-aware and adaptive
    - keep language simple and expressive
  - metrics
    - precision, recall, f-score, Pareto optimality
    - optimizing vs. satisficing
- Challenge: Adoption (~0.25 pages)
  - definitions
    - adoption in the sense of broad acceptance and use
  - why is it important
    - adoption of a streaming language would drive adoption of
      streaming technologies in general
    - more attractive for student to invest time to learn
    - broader pool of skilled people to hire for company
    - drive libraries, tools, benchmarks, optimizations, etc.
  - why difficult
    - large variety of approaches, none is widely adopted
  - what's unique to streaming
    - domain is young, fast-moving, prone to vendor lock-in
  - what's unique to languages
    - no consensus on which features are the most important
      and which can be omitted to reduce complexity
    - need well-defined semantics (counter DSEL trend)
  - goal(s)
    - community agrees upon few languages that get widely adopted
  - metrics
    - number of users: job postings, resumes, courses, LoC,
      citations in papers, mentions in support forums, ...
    - number of systems that support it, industry standard
- closing paragraph
  - we hope this summary of the working group discussion helps
    guide future research in novel and impactful directions
\end{alltt}
