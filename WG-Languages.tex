\subsection{Languages and Abstractions}\label{sec:wg_lang}

Based on the definitions and survey from the corresponding tutorial
(see Section~\ref{sec:tut_lang}), this working group identified and
described three challenges faced by stream processing languages.

\emph{Variety of data models} is a challenge for stream processing
languages. A data model organizes elements of data with respect to
their semantics, their logical composition into data structures, and
their physical representation. Producers and consumers of streams to
and from a streaming application dictate data models it must handle,
and the application's own conversion and processing needs drive
additional data-model variety.  There is no consensus on what a stream
data item is. At one extreme, in StreamIt, each data item is a simple
number~\cite{thies_et_al_2002}, while at the other extreme, C-SPARQL
streams entire self-describing graphs~\cite{barbieri_et_al_2009}.
Streaming languages have so far failed to consolidate on a data model
because data-model variety is a difficult challenge.

Data-model variety causes streaming-specific issues, since the data
model affects the speed of serialization, transmission, compression,
and dynamic checks for the presence or absence of certain fields, and
because the online setting leaves no time for separate batch data
integration. Some stream processing languages are designed around
their data model, e.g., CQL on tuples~\cite{arasu_babu_widom_2006} or
path expressions on XML trees~\cite{diao_et_al_2002}. Furthermore, the
data model enables streaming-language compilers to provide helpful
error messages and optimizations.

The goal is for streaming languages to let the programmer use the
logical data model they find most convenient while letting the
compiler choose the best physical representation. Metrics of success
are the expressive power of the language along with its throughput,
latency, and resource consumption.

\emph{Veracity with simplicity} is a challenge for stream processing
languages. Veracity means producing accurate and factual results, and
simplicity means avoiding unnecessary language complexity. There are
several reasons why streaming veracity is hard. Sensors producing
input data have limitations on precision, energy, and memory. In
long-running and loosely-coupled streaming applications, stream
sources come and go. And approximate stream
algorithms~\cite{babcock_et_al_2002} and stream
mining~\cite{gaber_zaslavsky_krishnaswamy_2005} introduce additional
uncertainty. This is compounded by the lack of ground truth in an
online setting, and by the difficulty of anticipating and testing
every eventuality.

Veracity causes streaming-specific issues, since it requires accurate
real-time responses without having seen all the data, and because the
online setting leaves no time for separate batch data cleansing. Also,
streaming is often used in a distributed setting, where there can be
no global clock~\cite{lamport_1978}. Some streaming languages are
studies in handling uncertainty on top of stream-relational
algebra~\cite{ali_et_al_2009,tran_et_al_2010}, but restricting stream
operators to support retraction or uncertainty propagation limits
expressiveness and raises complexity. A more general solution may use
probabilistic programming to handle uncertainty in a principled
way~\cite{gordon_et_al_2014}.

The goal is for streaming languages to help minimize compounding
uncertainty by being quality-aware and adaptive while remaining
simple, expressive, and fast. This inherently leads to multiple
metrics (e.g., precision, recall, throughput, latency) and
harder-to-quantify objectives (simplicity, expressiveness). One can
maximize one set of metrics while satisfycing a threshold on the
others, or one can seek Pareto-optimal
solutions~\cite{zhang_hirzel_grove_2016}.

\emph{Adoption} is a challenge for stream processing languages: while
there are many of them, none have reached broad acceptance and use.
The community should care about adoption of streaming languages
because it would drive adoption of streaming technologies in general.
A widely-adopted language is more attractive for students to learn,
leading to a bigger pool of skilled people to hire for companies.
Furthermore, a widely-adopted streaming language would drive more
mature libraries, tools, benchmarks, optimizations, etc. The lack of a
dominant language indicates that adoption is a difficult goal.

\begin{alltt}TODO\scriptsize 1 page
- Challenge: Adoption (~0.25 pages)
  - what's unique to streaming
    - domain is young, fast-moving, prone to vendor lock-in
  - what's unique to languages
    - no consensus on which features are the most important
      and which can be omitted to reduce complexity
    - need well-defined semantics (counter DSEL trend)
  - goal(s)
    - community agrees upon few languages that get widely adopted
  - metrics
    - number of users: job postings, resumes, courses, LoC,
      citations in papers, mentions in support forums, ...
    - number of systems that support it, industry standard
- closing paragraph
  - we hope this summary of the working group discussion helps
    guide future research in novel and impactful directions
\end{alltt}
