\subsection{Languages and Abstractions}\label{sec:wg_lang}

Based on the corresponding tutorial (Section~\ref{sec:tut_lang}), this
working group identified and described three challenges faced by
stream processing languages: variety of data models, veracity with
simplicity, and adoption of streaming languages. After the seminar,
some of the participants discussed these challenges more and distilled
out recommendations, published in the same survey paper that was
inspired by the tutorial~\cite{hirzel_et_al_2018}.

\iffalse
\para{Variety of Data Models.}
A data model organizes elements of data with respect to
their semantics, their logical composition into data structures, and
their physical representation. Producers and consumers of streams to
and from a streaming application dictate data models it must handle,
and the application's own conversion and processing needs drive
additional data-model variety.  There is no consensus on the definition of a stream
data item. At one extreme, in \name{StreamIt}, each data item is a simple
number~\cite{thies_et_al_2002}, while at the other extreme, \mbox{\name{C-SPARQL}}
streams entire self-describing graphs~\cite{barbieri_et_al_2009}.
Streaming languages have so far failed to consolidate on a unified data model
because data-model variety is a difficult challenge.

Data-model variety causes streaming-specific issues, since the data
model affects the speed of serialization, transmission, compression,
and dynamic checks for the presence or absence of certain fields, and
because the online setting leaves no time for separate batch data
integration. Some stream processing languages are designed around
their data model, e.g., \name{CQL} on tuples~\cite{arasu_babu_widom_2006} or
path expressions on XML trees~\cite{diao_et_al_2002}. Furthermore, the
data model enables streaming-language compilers to provide helpful
error messages and optimizations. The goal is for streaming languages to let the programmer use the
logical data model they find most convenient while letting the
compiler choose the best physical representation. Metrics of success
include the expressive power of the language along with its throughput,
latency, and resource consumption.

\para{Veracity with Simplicity.}
Veracity means producing accurate and factual results, and
simplicity means avoiding unnecessary language complexity. There are
several reasons why streaming veracity is hard. Sensors producing
input data have limited precision, energy, and memory. In
long-running and loosely-coupled streaming applications,
sources come and go. And approximate streaming
algorithms~\cite{babcock_et_al_2002} and stream
mining~\cite{gaber_zaslavsky_krishnaswamy_2005} introduce additional
uncertainty. This is compounded by the lack of ground truth in an
online setting and by the difficulty of anticipating and testing
every eventuality.

Veracity causes streaming-specific issues, since it requires accurate
real-time responses without having seen all the data, and because the
online setting leaves no time for separate batch data cleansing. Also,
streaming is often used in a distributed setting, where there can be
no global clock~\cite{lamport_1978}. Some streaming languages are
explorations in handling uncertainty on top of stream-relational
algebra~\cite{tran_et_al_2010}, but restricting stream
operators to support retraction or uncertainty propagation limits
expressiveness and raises complexity. A more general solution might use
probabilistic programming to handle uncertainty in a principled
way~\cite{gordon_et_al_2014}. The goal is for streaming languages to help minimize compounding
uncertainty by being quality-aware and adaptive while remaining
simple, expressive, and fast. This inherently leads to multiple
metrics (e.g., precision, recall, throughput, latency) and
harder-to-quantify objectives (simplicity, expressiveness). One can
maximize one set of metrics while satisficing a threshold on the
others, or one can seek Pareto-optimal
solutions~\cite{zhang_hirzel_grove_2016}.

\para{Adoption.} While
there are many languages, none have reached broad acceptance and use.
The community should care about the adoption of streaming languages
because it would drive adoption of streaming technologies in general.
A widely-adopted language is more attractive for students to learn,
leading to a bigger pool of skilled people to hire for companies.
Furthermore, a widely-adopted language would lead to more
mature libraries, tools, benchmarks, and optimizations. The lack of a
dominant language indicates that adoption is a difficult goal. Streaming as a domain is young, fast-moving, and prone to vendor
lock-in. Meanwhile, there is so far neither a consensus on a
streaming language nor even a consensus on which language
features are the most important and which can be omitted to reduce
complexity. Furthermore, several recent streaming systems have a DSEL,
which tends to have less well-isolated semantics and more
host-language dependencies than a stand-alone DSL. The goal is for the community to agree upon one or a few languages that get
widely adopted. Metrics for the adoption of a streaming language include
the number of applications written in it,
as well as mentions in resumes, job posting, courses, and support
forums. Adoption can also be measured by the number of streaming systems that
support a language, open-source and open-governance implementations,
and ultimately, an industry standard.
\fi 
