\subsection{Stream Processing Languages}

This tutorial gave an overview of several styles of stream processing
languages. The tutorial illustrated each style (e.g., relational,
synchronous, etc.) with a representative example language. Of course,
for each style, there is an entire family of languages, and this
tutorial did not aim to be exhaustive.

A \emph{stream} is a conceptually infinite ordered sequence of data
items, and a \emph{streaming application} is a computer program that
continuously ingests input streams and produces output streams.  A
\emph{stream processing language} is a DSL (domain-specific language)
for writing streaming applications. Some stream processing languages
are DSELs (domain-specific embedded languages~\cite{hudak_1998}),
which build on a general-purpose host language to obviate the need for
a dedicated compiler. For clarity, this tutorial focused on
stand-alone DSLs, not DSELs.

\emph{Streaming SQL} dialects are an attempt to be for streaming data
what SQL has been for data stored in a database. A prominent example
is CQL~\cite{arasu_babu_widom_2006}. CQL extends the familiar
select-from-where syntax of SQL with windows that turn the recent
history of a stream into a relation, as well as with constructs that
watch the changes happening to a relation over time and derive a
stream from them. CQL is implemented via translation into a streaming
extension of relational algebra.

\emph{Synchronous Dataflow} languages offer streaming with
deterministic concurrency for reliable embedded control systems. An
example is StreamIt~\cite{thies_et_al_2002}, where streaming
applications are graphs composed of only four constructs: individual
operators, pipe\-lines of operators, feedback loops, and split-merge
topologies that implement task parallelism. The StreamIt compiler
determines a repeating steady-state schedule, then exploits that for
optimizations such as operator fusion and data parallelism.

\emph{Big-Data Streaming} languages focus on large-scale stream
processing applications with a variety of data and processing
requirements. An example is SPL~\cite{hirzel_schneider_gedik_2017}.
SPL offers parallelism across both multi-core machines and
multi-machine clusters. SPL addresses a variety of data requirements
via rich data types and assorted parsing operators. And SPL addresses
a variety of processing requirements by letting programmers write new
first-class streaming operators in their language of choice.

\emph{Complex Event Processing} (CEP) patterns describe how to detect
high-level events from a sequence of low-level events in a
stream. CEP is usually implemented via some form of automaton. Given
that regular expressions are the most popular surface language for
automatons, Match\-Regex uses regular expressions for patterns over
streams~\cite{hirzel_2012}. Low-level events are detected via simple
predicates. In addition, aggregation functions over events serve to
both guide and summarize matches.

\emph{Reactive Programming} languages specify computation that depends
upon variables whose values change subject to streaming data, and
propagate any updates to the result of the computation. Reactive
programming is analogous to the behavior of spreadsheet formulas, and
ActiveSheets takes that analogy to its logical
conclusion~\cite{hirzel_et_al_2016}. Besides combining spreadsheets
and streams, ActiveSheets also augments them with time-based windows,
key-based partitioning, and an optimized implementation.

\emph{Controlled Natural Languages} (CNLs) are artificial languages
(such as programming languages) designed to look like natural
languages (such as English).  The META platform provides a CNL for
event-condition-action rules over event
streams~\cite{arnold_et_al_2016}. CNLs can be read and understood by
any speakers of the corresponding natural language even without
technical training required by normal programming languages. Using a
CNL for streaming therefore contributes to the democratization of
streaming.

Overall, the field of stream processing languages is diverse.  On the
formal side, Soul\'{e} et al.\ show how to unify three streaming languages
on a common core calculus~\cite{soule_et_al_2016}. Practical efforts
to consolidate and standardize should be informed by an overview of
the state of the art, which this tutorial provided.
